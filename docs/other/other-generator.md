# 生成器

## 什么是生成器

生成器拥有在一个函数块内暂停和恢复代码执行的能力。函数名称前面加一个星号（\*）表示它是一个生成器函数，生成器函数用来生成生成器，也叫生成器对象。（简单来说就是：生成器能够使生成器函数内部的代码暂停执行或者恢复执行）

```javascript
// 生成器函数声明
function* generatorFn() {}
// 生成器函数表达式
let generatorFn = function* () {};
// 作为对象字面量方法的生成器函数
let foo = {
  *generatorFn() {},
};
// 作为类实例方法的生成器函数
class Foo {
  *generatorFn() {}
}
// 作为类静态方法的生成器函数
class Bar {
  static *generatorFn() {}
}

//注意：箭头函数不能用来定义生成器函数。标识生成器函数的星号不受两侧空格的影响。
```

## 为什么会出现生成器 & 何处使用生成器

Generator 函数是为了提供一种更灵活、更强大的函数形式，以满足某些特定的编程需求，以下是一些使用生成器的原因：

1、异步编程：Generator 函数提供了一种更简洁、易读的方式来处理异步操作。通过使用 yield 表达式，可以在函数中暂停执行，并在异步操作完成后继续执行。这样可以避免回调地狱（callback hell）和复杂的 Promise 链式调用，使异步代码更易于理解和编写。

2、迭代器：Generator 函数可用于创建迭代器。通过使用 yield 语句生成序列的值，可以轻松地创建可以迭代的对象，并使用 for...of 循环或手动调用 next()方法进行遍历。这种迭代器的创建方式比传统的迭代器模式更简洁，使代码更易于编写和维护。

3、惰性计算：Generator 函数支持惰性计算，即只在需要时计算和生成值。这对于处理大量数据或无限序列非常有用，可以避免一次性计算所有值而导致的性能问题。

4、状态管理：Generator 函数可以在函数执行的不同阶段之间保存和管理状态。通过在函数内部使用变量，可以在每次调用 next()时保留函数的上下文和局部变量的值，实现了函数的暂停和恢复。

## 生成器和迭代器的关系

#### 生成器也是迭代器

调用生成器函数会产生一个生成器对象。生成器对象一开始处于暂停执行（suspended）的状态。与 迭代器相似，生成器对象也实现了 Iterator 接口，因此具有 next()方法。调用这个方法会让生成器 开始或恢复执行。
