import{_ as s,o as a,c as o,X as e}from"./chunks/framework.af6290ec.js";const n="/myBlog/assets/network-jwt-1.d7d52a85.jpg",l="/myBlog/assets/network-jwt-2.d6f949d0.jpg",C=JSON.parse('{"title":"JWT(JSON Web Token)","description":"","frontmatter":{},"headers":[],"relativePath":"network/network-jwt.md","filePath":"network/network-jwt.md"}'),p={name:"network/network-jwt.md"},t=e(`<h1 id="jwt-json-web-token" tabindex="-1">JWT(JSON Web Token) <a class="header-anchor" href="#jwt-json-web-token" aria-label="Permalink to &quot;JWT(JSON Web Token)&quot;">​</a></h1><p>JSON Web Token（缩写 JWT）是目前最流行的跨域认证解决方案，本文介绍它的原理和用法。</p><h2 id="一、跨域认证的问题" tabindex="-1">一、跨域认证的问题 <a class="header-anchor" href="#一、跨域认证的问题" aria-label="Permalink to &quot;一、跨域认证的问题&quot;">​</a></h2><p>互联网服务离不开用户认证。一般流程是下面这样。</p><ul><li><p>1、用户向服务器发送用户名和密码。</p></li><li><p>2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</p></li><li><p>3、服务器向用户返回一个 session_id，写入用户的 Cookie。</p></li><li><p>4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。</p></li><li><p>5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</p></li></ul><p>这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。</p><p>举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？</p><p>一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。</p><p>另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。</p><h2 id="二、jwt-的原理" tabindex="-1">二、JWT 的原理 <a class="header-anchor" href="#二、jwt-的原理" aria-label="Permalink to &quot;二、JWT 的原理&quot;">​</a></h2><p>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。</p><div class="language-JSON"><button title="Copy Code" class="copy"></button><span class="lang">JSON</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">姓名</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">张三</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">角色</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">管理员</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">到期时间</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">2018年7月1日0点0分</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。</p><p>服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</p><h2 id="三、jwt-的数据结构" tabindex="-1">三、JWT 的数据结构 <a class="header-anchor" href="#三、jwt-的数据结构" aria-label="Permalink to &quot;三、JWT 的数据结构&quot;">​</a></h2><p>实际的 JWT 大概就像下面这样。</p><p><img src="`+n+'" alt=""></p><p>它是一个很长的字符串，中间用点（<code>.</code>）分隔成三个部分。注意，JWT 内部是没有换行的，这里只是为了便于展示，将它写成了几行。</p><p>JWT 的三个部分依次如下。</p><ul><li>Header（头部）</li><li>Payload（负载）</li><li>Signature（签名）</li></ul><p>写成一行，就是下面的样子。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">Header.Payload.Signature</span></span></code></pre></div><p><img src="'+l+`" alt=""></p><p>下面依次介绍这三个部分。</p><h3 id="_3-1-header" tabindex="-1">3.1 Header <a class="header-anchor" href="#_3-1-header" aria-label="Permalink to &quot;3.1 Header&quot;">​</a></h3><p>Header 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。</p><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">alg</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">HS256</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">typ</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">JWT</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>上面代码中，<code>alg</code> 属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；<code>typ</code> 属性表示这个令牌（token）的类型（type），JWT 令牌统一写为 <code>JWT</code>。</p><p>最后，将上面的 JSON 对象使用 Base64URL 算法（详见后文）转成字符串。</p><h3 id="_3-2-payload" tabindex="-1">3.2 Payload <a class="header-anchor" href="#_3-2-payload" aria-label="Permalink to &quot;3.2 Payload&quot;">​</a></h3><p>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了 7 个官方字段，供选用。</p><ul><li>iss (issuer)：签发人</li><li>exp (expiration time)：过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号</li></ul><p>除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。</p><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">sub</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">1234567890</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">name</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">John Doe</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">admin</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">true</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。</p><p>这个 JSON 对象也要使用 Base64URL 算法转成字符串。</p><h3 id="_3-3-signature" tabindex="-1">3.3 Signature <a class="header-anchor" href="#_3-3-signature" aria-label="Permalink to &quot;3.3 Signature&quot;">​</a></h3><p>Signature 部分是对前两部分的签名，防止数据篡改。</p><p>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">HMACSHA256(</span></span>
<span class="line"><span style="color:#A6ACCD;">  base64UrlEncode(header) + &quot;.&quot; +</span></span>
<span class="line"><span style="color:#A6ACCD;">  base64UrlEncode(payload),</span></span>
<span class="line"><span style="color:#A6ACCD;">  secret)</span></span></code></pre></div><p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用&quot;点&quot;（<code>.</code>）分隔，就可以返回给用户。</p><h3 id="_3-4-base64url" tabindex="-1">3.4 Base64URL <a class="header-anchor" href="#_3-4-base64url" aria-label="Permalink to &quot;3.4 Base64URL&quot;">​</a></h3><p>前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。</p><p>JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符<code>+</code>、<code>/</code>和<code>=</code>，在 URL 里面有特殊含义，所以要被替换掉：<code>=</code>被省略、<code>+</code>替换成<code>-</code>，<code>/</code>替换成<code>_</code> 。这就是 Base64URL 算法。</p><h2 id="四、jwt-的使用方式" tabindex="-1">四、JWT 的使用方式 <a class="header-anchor" href="#四、jwt-的使用方式" aria-label="Permalink to &quot;四、JWT 的使用方式&quot;">​</a></h2><p>客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。</p><p>此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息 <code>Authorization</code> 字段里面。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">Authorization: Bearer &lt;token&gt;</span></span></code></pre></div><p>另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。</p><h2 id="五、jwt-的几个特点" tabindex="-1">五、JWT 的几个特点 <a class="header-anchor" href="#五、jwt-的几个特点" aria-label="Permalink to &quot;五、JWT 的几个特点&quot;">​</a></h2><ul><li><p>（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</p></li><li><p>（2）JWT 不加密的情况下，不能将秘密数据写入 JWT。</p></li><li><p>（3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</p></li><li><p>（4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</p></li><li><p>（5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</p></li><li><p>（6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</p></li></ul><h2 id="六、参考链接" tabindex="-1">六、参考链接 <a class="header-anchor" href="#六、参考链接" aria-label="Permalink to &quot;六、参考链接&quot;">​</a></h2><p><a href="https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" target="_blank" rel="noreferrer">阮一峰的网络日志-JSON Web Token 入门教程</a></p>`,53),r=[t];function c(i,d,D,y,u,F){return a(),o("div",null,r)}const A=s(p,[["render",c]]);export{C as __pageData,A as default};
