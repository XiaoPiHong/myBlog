import{_ as e,o,c as t,X as a}from"./chunks/framework.af6290ec.js";const s="/myBlog/assets/es-eventloop-1.6a4d1d5a.png",l="/myBlog/assets/es-eventloop-2.beacea19.png",n="/myBlog/assets/es-eventloop-3.db4ca213.png",r="/myBlog/assets/es-eventloop-4.b36e4e60.png",b=JSON.parse('{"title":"事件循环机制（Event Loop）","description":"","frontmatter":{},"headers":[],"relativePath":"js/es/es-eventloop.md","filePath":"js/es/es-eventloop.md"}'),p={name:"js/es/es-eventloop.md"},i=a('<h1 id="事件循环机制-event-loop" tabindex="-1">事件循环机制（Event Loop） <a class="header-anchor" href="#事件循环机制-event-loop" aria-label="Permalink to &quot;事件循环机制（Event Loop）&quot;">​</a></h1><h2 id="event-loop" tabindex="-1">event loop <a class="header-anchor" href="#event-loop" aria-label="Permalink to &quot;event loop&quot;">​</a></h2><p>js是一门单线程的语言，它的异步和多线程是通过Event Loop事件循环机制来实现的。大体由但部分组成：</p><ul><li>调用栈（call stack）</li><li>消息队列（Message Queue）</li><li>微任务队列（Microtask Queue）</li></ul><p><img src="'+s+'" alt=""></p><h2 id="event-loop的执行" tabindex="-1">event loop的执行 <a class="header-anchor" href="#event-loop的执行" aria-label="Permalink to &quot;event loop的执行&quot;">​</a></h2><p>eventloop开始时会从全局的代码一行一行往下执行，遇到函数调用，会把函数压入到调用栈中，被压入的函数叫做帧（Frame），当被压入的函数 return 返回后会从调用栈中弹出。</p><p><img src="'+l+'" alt=""></p><h2 id="案例1-不涉及队列" tabindex="-1">案例1（不涉及队列） <a class="header-anchor" href="#案例1-不涉及队列" aria-label="Permalink to &quot;案例1（不涉及队列）&quot;">​</a></h2><p><img src="'+n+'" alt=""></p><h2 id="案例2-涉及消息队列" tabindex="-1">案例2（涉及消息队列） <a class="header-anchor" href="#案例2-涉及消息队列" aria-label="Permalink to &quot;案例2（涉及消息队列）&quot;">​</a></h2><p>js中的异步操作，如：fetch、事件回调、（setTimeout、sesetInterval中的回调函数）会入队到消息队列中（宏任务队列），为消息，消息会在调用栈清空的时候压入到调用栈中执行，这也是为什么setTimeout中的延迟参数只是最小延迟时间。</p><p><img src="'+r+'" alt=""></p>',13),c=[i];function _(h,d,m,v,u,f){return o(),t("div",null,c)}const q=e(p,[["render",_]]);export{b as __pageData,q as default};
